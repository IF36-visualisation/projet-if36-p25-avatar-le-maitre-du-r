---
title: "Rapport Analyse IF36 - Catalogue des jeux Steam"
author: "Hoang-Viêt LE, Paul LASSASEIGNE, Florian LOPITAUX et Jules PERRIN"
date: "2025-04-28"
output:
  html_document:
    template: template.html
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE, 
  warning = FALSE,
  results = 'hide' 
)
```

### Membres du groupe

-   Hoang-Viêt LE
-   Paul LASSASSEIGNE
-   Jules PERRIN
-   Florian LOPITAUX

# Steam

Steam est une plateforme de distribution de jeux vidéo développée par Valve.

Elle permet aux utilisateurs d’acheter, télécharger et jouer à une grande variété de jeux sur PC, Mac et Linux. En plus de proposer un vaste catalogue de jeux (environ 140 000 jeux), Steam offre des évaluations et avis de joueurs sur les jeux de son catalogue.

![](img/store_home_share.jpg)

# Données

Dans le cadre de notre projet, nous avons choisi d'étudier divers jeux de données autour du catalogue de jeux Steam. Les datasets utilisés lors de ce projet sont les suivants :

- [Dataset de NewbieIndieGameDev datant d'Octobre 2024](https://github.com/NewbieIndieGameDev/steam-insights) (140 000 jeux recensés)

Les datasets sont sous format de différents fichiers csv. Cependant, NewbieIndieGameDev utilisant probablement un logiciel tiers pour manipuler ses données, certains csv sont mal formatés et imparsables par un programme (données json dans une colonne, balises html, ...). <br> Nous devons donc les modifier au préalable. Nous avons déjà "reformaté" le fichier **games.csv** afin de le rendre lisible par nos programmes et vérifier que nous sommes bien capables de les traiter pour notre projet. <br> Ainsi dans le dossier data : pour chaque fichier qui possède ce problème, il y aura un fichier **raw\_**<nom_du_fichier>.csv qui sont les données brutes ("illisibles") et **clean\_**<nom_du_fichier>.csv qui sont les données reformatées pour qu'elles soient "lisibles".

Ces datasets possèdent de nombreuses variables. Nous allons nous concentrer sur ceux qui nous semblent assez pertinentes à analyser. Description des fichiers et de leur contenu :

-   **`games.csv`** : regroupe les métadonnées des jeux, notamment :
    -   `app_id` (*discrètes*) : identifiant unique du jeu sur Steam
    -   `name` (*nominales*) : titre du jeu
    -   `price` (*continues*) : prix d'achat
    -   `languages` (*nominales*) : les langues disponibles sur le jeu
-   **`steamspy.csv`** : fournit des données issues de SteamSpy, incluant :
    -   `app_id` (*discrètes*) : identifiant unique du jeu sur Steam
    -   `developer` (*nominales*) : studio de développement
    -   `publisher` (*nominales*): éditeur du jeu
    -   `owners_range`(*discretes/continues*) : plage estimée du nombre de propriétaires du jeu
    -   `playtime_median` (*discrètes*) : durée médiane de jeu par utilisateur
    -   `concurrent_users_yesterday` (*discrètes*) : nombre total de joueurs connectés (octobre 2024)
    -   `genres` (*nominales*) : catégorie du jeu
-   **`tags.csv`** : répertorie les tags attribués à chaque jeu (différents des genres).
    -   `app_id` (*discrètes*) : identifiant unique du jeu sur Steam
    -   `tag` (*nominales*) : tag associé au jeu
-   **`reviews.csv`** : contient des informations sur les avis des joueurs :
    -   `app_id` (*discrètes*) : identifiant unique du jeu sur Steam
    -   `review_score_description` (*oridnales*) : évaluation globale (Overwhelmingly Positive, Very Positive, Mixed, etc.)
    -   `positive` / `negative` (*nominales*) : nombre d’avis positifs et négatifs
    -   `metacritic_score` (*discrètes*) : note Metacritic
    -   `recommendations` (*discrètes*) : nombre de recommandations sur Steam
-   **`categories.csv`** : liste les catégories officielles Steam associées aux jeux.
    -   `app_id` (*discrètes*) : identifiant unique du jeu sur Steam
    -   `category` (*nominales*) : catégorie associée au jeu

# Plan d'analyse

Nous tenons à éviter de reproduire les mêmes analyses et visualisations que NewbieIndieGameDev disponible sur ce lien : [Vidéo sur l'analyse des données par NewbieIndieGameDev](https://www.youtube.com/watch?v=qiNv3qv-YbU)

Avec ces nombreuses données et variables, de nombreuses pistes d'analyse sont possibles :

### Notes et avis des joueurs

-   Une corrélation est-elle identifiable entre les avis/note (Métacritics ou joueurs) et le temps de jeu ?
-   Les avis Metacritic sont-elles corrélées avec les avis données par les joueurs sur la plateforme ?
-   Voir l'évolution des évaluations des joueurs des jeux AAA

### Genres des jeux

-   Quels sont les catégories les plus populaires sur Steam actuellement ?
-   Quel est la tendance des jeux sortis récemment ? (genre, jeux indépendants ou AAA, etc...)
-   Observer l'évolution des genres de jeu sortis pour déceler des "modes" et période où certains genre de jeux était les plus populaires ?
-   À partir des résultats de l'observation précédente, essayer de comprendre une montée ou baisse des genres.
    -   Exemple (simple) : est-ce que la croissance du genre battle royale peut-être corrélée/causée avec la sortie du jeu Fortnite
    -   Exemple (complexe) : Peut-on observer une corrélation entre la sortie de jeux en ligne et le déploiement d'internet dans le monde (nécessite de trouver des données sur le déploiement d'internet)

### Jeux indépendants vs AAA

-   Les jeux indépendants obtiennent-ils des meilleures évaluations que les AAA ?
-   Quelle est la durée de vie d'un jeu indépendant comparée à un AAA? (on essayera de prendre des jeux avec des genres assez similaires)
-   Les genres/tags des jeux indépendants sont-ils plus "innovants" que les AAA ?

### Prix

-   Quels sont les facteurs qui impactent globalement le prix ? (les genres/tags de jeux les plus chers, plus de langues disponibles \<=\> prix plus chers ?)
-   Comparer des jeux avec des avis/notes similaires mais des prix différents pour voir si le temps de jeu moyen est impacté (est-ce que le prix peut influer le joueur à plus jouer pour le "rentabiliser")
-   Comparer les moyennes des prix des jeux par développeurs / studio de développement, pour potentiellement identifier des stratégies économiques chez certains.

### Jeux en ligne

-   Quels sont les types de jeu en ligne les plus populaires sur Steam ? (FPS, MMO, etc...)
-   Déceler certains jeux avec un fort nombre de joueurs connectés et essayer de l'associer à un évènement à ce moment (octobre 2024) qui explique ce nombre élevé : mise à jour conséquente, évènement d'influenceur relançant l'intérêt pour le jeu, etc...

### Différences culturelles/géographique et leurs impacts

-   Etudier les langues disponibles selon les jeux des développeurs afin de potentiellement déceler des marchés/régions priorisés.

## Variables à comparer/Visualisations à réaliser

Voici une liste non exhaustive des variables comparées ainsi que les visualisations que l'on va réaliser : - Nombre de jeux par genre/catégorie, avec possibilité de filtrer par date de sortie pour analyser les tendances récentes. - Comparaison entre les scores Metacritic et les avis des utilisateurs sur Steam. - Corrélation entre le nombre de langues disponibles et le nombre de propriétaires d’un jeu. - Comparaison entre les jeux issus d’un studio indépendant et ceux d’un grand studio, en comparant l’évolution des ventes réalisées, le prix des jeux et les avis des joueurs (ex : les jeux du studio Supergiant Games vs Ubisoft). - Analyse des combinaisons de genres les plus fréquentes pour les jeux indépendants et les jeux AAA, afin de mettre en évidence des différences de positionnement. - Évolution des prix de lancement des jeux au fil du temps.

## Problèmes et limitations

-   Le dataset que l'on a choisi est un "snapshot" du SteamLibrary datant d'octobre 2024. On ne pourra pas réaliser de comparaisons dans le temps à part dans certains rares cas où les variables nous le permettent (prix initial d'un jeu, etc...)
-   Pour certaines données notamment provenant de SteamSpy, ce sont des estimations donc les analyses sur ces données perdront une certaine précision


## ------------------------------------------------------------------------

```{r import}
library(scales)
library(lubridate)
library(tidyverse)
library(corrr)
library(knitr)

# Utilisé par Paul
reviews <- read_csv("data/raw_reviews.csv") %>%
    filter(grepl("^\\d+$", app_id)) %>%
    mutate( app_id = as.character(app_id))
tags <- read_csv("data/tags.csv")

# Utilisé par Viêt 
# Regrouper les genres des fichiers categories et tags sous une même ligne
tags_regroup <- read.csv("data/tags.csv") %>% 
  group_by(app_id) %>% 
  summarize(tags = paste(tag, collapse = ","))

categories <- read.csv("data/categories.csv") %>% 
  group_by(app_id) %>% 
  summarize(categories = paste(category, collapse = ","))

# Importer les autres tableaux
steamspy <- read_csv("data/steamspy.csv")

# Import de clean_games
clean_games <- read.csv("data/clean_games.csv", sep=";")

# Créer un dataframe contenant toutes les informations en réalisant des jointures
steamData <- left_join(clean_games, steamspy, by="app_id") %>% 
  left_join(tags_regroup, by="app_id") %>% 
  left_join(categories, by="app_id") %>%
  mutate(app_id = as.character(app_id)) %>%
  left_join(reviews, by="app_id")

# Mettre les tags et catégories en lowercase pour les str_detect
steamData <- steamData %>%
  mutate(
    # Nettoyer les champs : enlever les espaces superflus, mettre en minuscules pour str_detect
    categories = str_to_lower(str_trim(categories)),
    tags = str_to_lower(str_trim(tags))
  )

# Trabnsformer toutes les valeurs "\\N" en NA
steamData <- steamData %>%
  mutate(across(where(is.character), ~ na_if(., "\\N")))

# Retirer les colonnes en double et renomme les colonnes précédentes
steamData <- steamData %>%
  select(-price.y, -languages.y) %>%
  rename(price = price.x,
         languages = languages.x)

# Modifier la colonne initial_price pour qu'elle corresponde à sa valeur en USD
# Checker si le jeu possède une valeur valide (pour le diviser par 100 sinon NA)
steamData <- steamData %>%
  mutate(initial_price = if_else(!is.na(initial_price), as.double(initial_price) / 100, NA) )

# Ajouter les colonnes "proportion_avis_positif" et "proportion_avis_positif_steamspy"
steamData <- steamData %>%
  mutate(
    proportion_avis_positif = if_else(total != 0, positive / total, NA),
    proportion_avis_positif_steamspy = if_else((steamspy_positive + steamspy_negative) != 0, steamspy_positive / (steamspy_positive + steamspy_negative), NA)
  )

# Transformer les données string en valeurs 
steamData <- steamData %>%
  mutate(
    release_date = ymd(release_date),
    initial_price = as.numeric(initial_price),
    price = as.numeric(price),
    concurrent_users_yesterday = as.numeric(concurrent_users_yesterday),
    metacritic_score = as.numeric(metacritic_score),
    steamspy_score_rank = as.numeric(steamspy_score_rank),
    recommendations = as.numeric(recommendations)
  )

# Utilisé par Florian

games <- read_delim("./data/clean_games.csv", delim=";", show_col_types = FALSE)

# Utilisé par Jules

steamspy <- read_csv("data/steamspy.csv")
```

# Analyse descriptive

Dans cette partie, nous allons chercher à analyser les différentes variables de notre dataset importé afin d'appréhender les données que nous avons choisis. Nous chercherons à calculer les moyennes et les écarts-types des variables numériques (pour le prix, le nombre d'avis, etc...).
Nous étudierons également la répartition de différentes valeurs au sein du dataset (tags, owner_range, etc..).
Enfin, nous construirons également une matrice de corrélation afin d'examiner les possibles relations entre les variables du dataset.

## Moyennes et Écarts-types

```{r mean_and_sd, results='markup'}
# Variables pertinents pour la moyenne et l'écart-type
steamSummarise = steamData %>%
  summarise(
    moyenne_joueurs = mean(concurrent_users_yesterday, na.rm = TRUE),
    ecart_type_joueurs = sd(concurrent_users_yesterday, na.rm = TRUE),
    moyenne_prix = mean(price, na.rm=TRUE),
    ecart_type_prix = sd(price, na.rm = TRUE),
    moyenne_note = mean(review_score, na.rm=TRUE),
    ecart_type_note = sd(review_score, na.rm=TRUE),
    moyenne_metacritic_score = mean(metacritic_score, na.rm=TRUE),
    ecart_type_metacritic_score = sd(metacritic_score, na.rm=TRUE),
    moyenne_avis = mean(total, na.rm=TRUE),
    ecart_type_avis = sd(total, na.rm=TRUE),
)

# 1. Transforme en dataframe clé/valeur
df_long <- steamSummarise %>%
  pivot_longer(everything(), names_to = "variable_stat", values_to = "valeur")

# 2. Sépare la colonne variable_stat en stat (moyenne/écart_type) et variable
df_long <- df_long %>%
  mutate(
    stat = case_when(
      grepl("^moyenne", variable_stat) ~ "Moyenne",
      grepl("^ecart_type", variable_stat) ~ "Écart-type"
    ),
    variable = gsub("^(moyenne|ecart_type)_", "", variable_stat)
  ) %>%
  select(variable, stat, valeur)

# 3. On remet au format large avec une colonne par stat
tableau_stat <- df_long %>%
  pivot_wider(names_from = stat, values_from = valeur) %>%
  mutate(variable = case_when(
    variable == "joueurs" ~ "Nombre de joueurs actif",
    variable == "prix" ~ "Prix",
    variable == "note" ~ "Note sur Steam",
    variable == "metacritic_score" ~ "Note Metacritic",
    variable == "avis" ~ "Nombre d'avis",
    TRUE ~ variable
  ))

# Affichage
kable(tableau_stat, col.names = c("Variable", "Moyenne", "Ecart-Type"), caption = "Statistiques descriptives des principales variables", digits = 2)
```

Notes :

- La moyenne des notes Metacritics ne concerne que les jeux ayant reçu cette note
- La moyenne des prix ne concerne uniquement les jeux payants

## Répartition de différentes variables

### Répartition de la plage de propriétaires des jeux Steam

```{r owner_count_repartition, results='markup'}
# Compter le nombre de jeux par plage de propriétaires
owners_count <- steamData %>%
  group_by(owners_range) %>%
  summarise(nb_jeux = n(), .groups = "drop")

# Enlever la colonne "NA" et traiter les plages
owners_count_clean <- owners_count %>%
  filter(!is.na(owners_range)) %>%
  mutate(
    # Extraire la borne inférieure comme nombre (en retirant les virgules)
    owners_min = as.numeric(str_remove_all(str_extract(owners_range, "^[0-9,]+"), ",")),
    # Réordonner selon la borne inférieure
    owners_range = fct_reorder(owners_range, owners_min)
  )

# Fonction pour convertir les nombres en format court (ex: 10000 -> 10k, 1000000 -> 1M)
shorten_number <- function(x) {
  x <- as.numeric(gsub(",", "", x))
  if (is.na(x)) return(NA_character_)
  else if (x >= 1e6) return(paste0(x / 1e6, "M"))
  else if (x >= 1e3) return(paste0(x / 1e3, "k"))
  else return(as.character(x))
}

# Modifier les labels en remplaçant " .. " par " - " et en raccourcissant les nombres
owners_count_clean <- owners_count_clean %>%
  mutate(
    owners_range_char = as.character(owners_range),
    owners_range_short = sapply(strsplit(owners_range_char, " \\.\\. "), function(x) {
      paste0(shorten_number(x[1]), " - ", shorten_number(x[2]))
    }),
    # Convertir en facteur en gardant l'ordre d'origine (avec owners_range)
      owners_range_short = factor(owners_range_short, levels = owners_range_short[order(owners_min)])
  )

# Visualisation
ggplot(owners_count_clean, aes(x = nb_jeux, y = owners_range_short)) +
  geom_col(fill = "#99CCFF") +
  
  # Labels à l'intérieur des barres pour les grandes valeurs (>= 100)
  geom_text(
    data = owners_count_clean %>% filter(nb_jeux >= 100),
    aes(x = nb_jeux, label = label_number(big.mark = " ")(nb_jeux)),
    hjust = 1.2, color = "#002244", size = 3.5
  ) +
  
  # Labels à l'extérieur à droite pour les petites valeurs (< 100)
  geom_text(
    data = owners_count_clean %>% filter(nb_jeux < 100),
    aes(x = nb_jeux, label = label_number(big.mark = " ")(nb_jeux)),
    hjust = -0.2, color = "#002244", size = 3.5
  ) +
  
  scale_x_continuous(
    trans = pseudo_log_trans(base = 10),
    breaks = c(1, 10, 100, 1000, 10000, 100000),
    labels = label_number(big.mark = " ")
  ) +
  labs(
    title = "Nombre de jeux par plage de propriétaires",
    x = "Nombre de jeux (échelle pseudo-log)",
    y = "Plage de propriétaires"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.title.y = element_text(size = 12),
    axis.title.x = element_text(size = 12),
    axis.text.y = element_text(size = 8)
  ) +
  coord_cartesian(clip = "off")
```

Note :

- Ces données proviennent de SteamSpy. Un autre outil existe pour estimer le nombre de copies vendues au total (Gamalytic), mais ce service est payant

### Répartition des jeux Steam sortis par année

```{r game_released_by_year, results='markup'}
# Extraire l'année et compter les jeux par année
jeux_par_annee <- steamData %>%
  mutate(annee_sortie = lubridate::year(release_date)) %>%
  filter(!is.na(annee_sortie)) %>%
  group_by(annee_sortie) %>%
  summarise(nb_jeux = n()) %>%
  arrange(annee_sortie)

ggplot(jeux_par_annee, aes(x = annee_sortie, y = nb_jeux)) +
  geom_col(fill = "#2C7FB8") +
  scale_x_continuous(breaks = pretty(jeux_par_annee$annee_sortie, n = 10)) +
  scale_y_continuous(labels = scales::comma) +
  labs(
    title = "Nombre de jeux sortis par année",
    x = "Année de sortie",
    y = "Nombre de jeux"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )
```

```{r game_released_by_year_log, results='markup'}

ggplot(jeux_par_annee, aes(x = annee_sortie, y = nb_jeux)) +
  geom_col(fill = "#2C7FB8") +
  scale_x_continuous(breaks = pretty(jeux_par_annee$annee_sortie, n = 10)) +
  scale_y_continuous(
    trans = pseudo_log_trans(base = 10),
    breaks = c(1, 10, 100, 1000, 10000, 20000),
    labels = comma_format()
  ) +
  labs(
    title = "Nombre de jeux sortis par année (échelle pseudo-logarithmique)",
    x = "Année de sortie",
    y = "Nombre de jeux (pseudo-log scale)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )
```

Notes : 

- On observe l'absence de jeux sortis en 2002 et une augmentation nette à partir de 2006.
- Une explication plausible est que la plateforme Steam est sortie en 2003 et était dédiée à la distribution des mises à jour des jeux Valve. C'est qu'à la fin de l'année 2005 que Steam décide de distribuer des jeux tiers sur son marché.

Source : [Lien Wikipédia de Steam](https://en.wikipedia.org/wiki/Steam_\(service\))

### Répartition des genres des jeux Steam

```{r genres, results='markup'}
# Séparer les genres (s'ils sont séparés par des virgules), enlever les espaces, et compter
genres_par_jeu <- steamData %>%
  filter(!is.na(genres)) %>%
  separate_rows(genres, sep = ",") %>%
  mutate(genres = str_trim(genres)) %>%
  group_by(genres) %>%
  summarise(nb_jeux = n()) %>%
  arrange(desc(nb_jeux)) %>%
  filter(nb_jeux > 1000)

genres_par_jeu %>%
  mutate(genres = fct_reorder(genres, nb_jeux)) %>%  # trie les genres selon le nombre de jeux
  ggplot(aes(x = nb_jeux, y = genres)) +
  geom_col(fill = "#1f77b4") +
  geom_text(aes(label = comma(nb_jeux)), hjust = -0.1, color = "black", size = 3) +
  labs(
    title = "Nombre de jeux par genre",
    x = "Nombre de jeux",
    y = "Genre"
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, 0.1)), labels = comma_format()) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.title = element_text(size = 12)
  )
```

Note :

- Nous avons retiré les genres qui ne comptaient moins de 1000 jeux pour se concentrer sur les genres principaux des jeux Steam. La plupart des autres genres retirés étaient des genres de niche (Cinéma ou d'autres genres concernant les logiciels disponibles sur Steam).

## Matrice de corrélation

```{r correlation_matrix, results='markup'}
# Matrice de corrélation
numeric_cols <- steamData %>%
  select(
    users = concurrent_users_yesterday,
    prix = price,
    prix_init = initial_price,
    avis_pos = positive,
    avis_neg = negative,
    avis_total = total,
    note_utilisateur = review_score,
    note_metacritic = metacritic_score,
    pos_spy = steamspy_positive,
    neg_spy = steamspy_negative,
    reco = recommendations,
    prop_positif = proportion_avis_positif,
    prop_positif_spy = proportion_avis_positif_steamspy
  ) %>% 
  filter(!is.na(avis_pos), !is.na(avis_neg), !is.na(note_utilisateur))

# 1. Calcul matrice corrélation
cor_matrix <- numeric_cols %>%
  select_if(is.numeric) %>%
  correlate()

vars <- cor_matrix$term

# 2. Passage en format long avec diagonale incluse
cor_long <- cor_matrix %>%
  pivot_longer(-term, names_to = "y", values_to = "r") %>%
  rename(x = term) %>%
  mutate(
    pos_x = match(x, vars),
    pos_y = match(y, vars),
    is_diag = pos_x == pos_y
  ) %>%
  filter(pos_x >= pos_y)

# 3. Plot ggplot avec diagonale gris clair
ggplot(cor_long, aes(x = x, y = y)) +
  geom_tile(
    data = cor_long %>% filter(!is_diag),
    aes(fill = r),
    color = "white"
  ) +  # triangle supérieur
  geom_tile(
    data = cor_long %>% filter(is_diag),
    fill = "grey90",    # diagonale sobre en gris clair
    color = "white"
  ) +
  geom_text(
    aes(label = ifelse(is_diag, "", round(r, 2))),
    color = "black",
    size = 3
  ) +
  scale_fill_gradient2(
    low = "blue", high = "red",
    limit = c(0, 1),
    name = "Corrélation"
  ) +
  scale_x_discrete(position = "top", limits = rev(vars)) +
  scale_y_discrete(limits = rev(vars)) +
  theme_minimal() +
  labs(
    title = NULL,
    x = NULL,
    y = NULL,
    caption = "Matrice de corrélation de différentes variables du dataset"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 0, vjust = 0.5, size = 10),
    axis.text.y = element_text(size = 10),
    plot.caption = element_text(hjust = 0.5, size = 14, face = "bold"),
    axis.ticks = element_blank(),
    panel.grid = element_blank()
  ) +
  coord_fixed(ratio = 1)
```

Avec cette matrice de corrélation, on peut noter les remarques suivantes :

- Le nombre d'avis positif semble être corrélé avec le nombre de recommendation (0.93)
- La note Metacritic n'est pas forcément corrélé avec la proportion de notes positives (0.53)
- Certaines valeurs obtenues doivent être discutées comme la corrélation entre le nombre de recommendation et le nombre d'avis positive/négative. En effet, comme il s'agit d'une valeur comptée, cela peut biaiser l'interprétation de la corrélation. En prenant en compte la proportion, nous obtenons une valeur quasi-nulle. 

Notes :

- Il n'existe pas de corrélation négative dans nos données
- Nous avons omis la proportion d'avis négative dans le tableau car nous obtenons juste le résultat inverse que pour la corrélation pour les avis positive.

## ------------------------------------------------------------------------

### Partie Analyse Prix (Florian LOPITAUX)

Dans cette section, nous allons nous intéresser aux facteurs qui peuvent avoir une influence sur le prix des jeux. Nous avons à partir des données de notre jeu de données relevé différents aspects qui seraient intéressants d'analyser afin de mieux comprendre comment est défini le prix d'un jeu.

Chaque aspect sera approfondi dans sa partie : contexte (pourquoi on se pose la question), traitement des données, analyse (graphique) et conclusion.

Voici les aspects que nous analyserons :

-   le nombre de langues disponibles sur un jeu : est-ce que le coût de traduction impacte le prix du jeu ?

-   les genres/tags des jeux : est-ce qu'on peut observer une différence en moyenne significative entre certains genres/tag de jeu ? Par exemple : Un jeu RPG open-world en 3D serait plus complexe et cher à déveloper qu'un plateformer 2D et donc plus cher ?

-   l'évolution des prix au fil du temps ? Est-ce qu'on peut observer une hausse des prix des jeux en fonction de leur date de sortie ?

-   Y a t-il des différences de prix notables entre les studios de développement ? Ce dernier aspect sera à mettre en relation avec l'aspect étudié précédent sur les genres/tags de jeu que développent les studios.

**Préambule** : Comme nous sommes actuellement pour le premier rendu, seul le premier aspect (les langues) de cette section sur les prix sera traité dans ce rendu. D'autres parts, de nouveaux aspects pourraient être ajoutés d'ici le rendu final si nous en trouvons durant notre analyse.

### Filtrage des données

Avant de passer à l'analyse, nous devons d'abord filtrer nos données, notamment celles où nous n'avons pas d'informations sur le prix. Ce manque d'information s'explique soit car le jeu est gratuit (free-to-play \<=\> F2P), soit par une erreur dans les données.

Nous décidons de ne pas prendre en compte les jeux gratuits dans nos analyses du prix et de les analyser distinctement dans une autre section.

```{r filter_price}
print(paste0("Nombre total de lignes du dataframe : ", nrow(games)))

games_price <- games %>% filter(is_free == 0)
print(paste0("Nombre de lignes sans les F2P : ", nrow(games_price)))

games_price <- games_price %>% filter(!is.na(price))
print(paste0("Nombre de lignes sans les F2P + erreurs de données : ", nrow(games_price)))
```

De plus, notre jeu de données contient une colonne "currency" contenant la devise de la monnaie utilisée pour exprimé le prix du jeu. Voici un bar plot montrant le pourcentage de représentation de chaque devise présente dans le dataframe.

```{r currency_plot}
currency_stats <- games_price %>%
  count(currency) %>%
  mutate(percentage = n / sum(n) * 100)

ggplot(currency_stats, aes(x = currency, y = percentage, fill = currency)) +
  geom_bar(stat = "identity") +
  labs(title = "Répartition des devises", x = "Devise", y = "Pourcentage d'utilisation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

On observe que l'écrasante majorité des prix sont formulés sous la devise de l'EURO. La solution optimale serait de convertir les prix avec une autre devise en EURO afin de pouvoir les comparer. Toutefois, dû à la complexité de la tâche et au manque de temps nous décidons de simplifier et d'utiliser uniquement les jeux exprimés en EURO.

```{r filter_currency}
print(paste0("Nombre de lignes avec toutes les devises : ", nrow(games_price)))
games_price <- games_price %>% filter(currency == "EUR")
print(paste0("Nombre de lignes avec uniquement les jeux en EURO : ", nrow(games_price)))
```

Enfin, nous devons également enlever les lignes qui ne contiennent pas d'informations sur les langues disponibles des jeux.

```{r filter_no_language}
games_languages <- games_price %>% filter(!is.na(languages))
print(paste0("Nombre de lignes sans les jeux avec aucune information sur les langues : ", nrow(games_languages)))
```

On observe que cette étape supprime peu de lignes, on en déduit donc que les lignes où il y avait une erreur dans les prix sont probablement en majorité les mêmes lignes où il y a eu une erreur avec les langues et qu'il n'y a pas d'information.

### L'impact des langues disponibles

Maintenant que le filtrage de données nécessaires pour cette partie est terminé, nous pouvons commencer notre analyse !

Notre objectif est de trouver une potentielle corrélation entre le prix des jeux et le nombre de langues disponibles. En effet, hormis la langue originale du jeu (celle du studio qui l'a développé), chaque langue disponible en plus nécessite un coût supplémentaire pour le studio de développement qui doit engager une équipe de traduction. De plus, cette traduction demande parfois des adaptations visuelles d'éléments graphiques directement dans le jeu, par exemple : si les langues sont extrêmement différentes (langues asiatiques fonctionnant sur un système d'idéogrammes et langues occidentales se basant sur l'alphabet latin).

De ce fait, il nous paraît possible que ce coût puisse avoir une répercussion sur le prix du jeu et donc qu'on puisse observer une corrélation entre ces deux éléments avec nos données.

Pour ce faire, nous allons d'abord devoir calculer le nombre de langues par jeu, rajoutons une nouvelle colonne 'nb_languages' qui contiendra ce nombre :

```{r nb_languages}
games_languages <- games_languages %>%
  mutate(
    nb_languages = str_split(languages, ",") %>% map_int(~ length(.x))
  )

head(games_languages)
```

Et voilà maintenant que ceci est fait nous pouvons maintenant créer notre graphique afin de voir, si oui ou non, une corrélation est observable. Pour ce graphique, nous décidons de partir sur un "scalar plot" avec comme axe horizontal le prix des jeux et comme axe vertical le nombre de langues disponibles :

```{r languages_graph}
ggplot(games_languages, aes(x = price, y = nb_languages)) +
  geom_point(color = "blue", alpha = 0.5) +
  labs(title = "Corrélation entre le Prix des jeux et le nombre de Langues disponibles",
       x = "Prix (€)",
       y = "Nombre de Langues") +
  theme_minimal()
```

Comme vous pouvez le constater le graphique est très peu lisible à cause de ses échelles, cela est dû aux points dits "outlier" : des points extrêmes en prix ou nombre de langues relevant "d'anomalie" et ne représentant pas la masse des données.

Nous décidons donc de les enlever pour réduire l'échelle et mieux pouvoir analyser le graphique.

```{r languages_graph_2}
games_languages <- games_languages %>% filter(nb_languages < 50) %>% filter(price <= 100)

ggplot(games_languages, aes(x = price, y = nb_languages)) +
  geom_point(color = "blue", alpha = 0.5) +
  labs(title = "Corrélation entre le Prix des jeux et le Nombre de Langues disponibles",
       x = "Prix (€)",
       y = "Nombre de Langues") +
  theme_minimal()
```

Comme nous pouvons l'observer, de nombreux jeux possédant le même nombre de langues se vendent à des prix très différents et inversement de nombreux jeux aux mêmes prix possèdent un nombre de langues très différents. De plus, nous n'observons pas d'augmentation de prix de façon linéaire par rapport au nombre de langues disponibles.

**Il ne semble donc pas y avoir de corrélation entre le nombre de langues disponibles et le prix d'un jeu.**

Notre hypothèse concernant les moyens et coûts de traduction qui pourraient impacter le prix est donc fausse. Cela nous parraît cohérent étant donné qu'aujourd'hui le support multi-language est devenu une norme pour une grande partie des jeux. Les studios aujourd'hui visent un marché international et donc doivent rendre leurs jeux accessibles pour ces marchés.


### ------------------------------------------------------------------------


## 🕹️ Types de jeux en ligne sur Steam (Hoang-Viêt LE)

### 🔍 Différences entre Catégorie et Tag

Sur Steam, il existe deux types de variables qui permettent de classer les jeux présents sur la plateforme :

- **Catégories** : classifications officielles attribuées par Steam. Elles décrivent les fonctionnalités principales du jeu.
Exemples : `Multijoueur`, `Succès Steam`, `Support manette`, `Mode coopératif`.

- **Tags** : classifications collaboratives créées par les utilisateurs. Ils décrivent le contenu, l’ambiance ou le style du jeu.
Exemples : `Puzzle`, `Narratif`, `Indépendant`, `FPS`, `Monde ouvert`.

![Tags et Catégories de Portal 2 sur Steam](img/portal_tag_categories.png){width=50%}

### 📌 Contexte et problématique

Steam est un acteur majeur dans le développement du jeu en ligne avec des titres cultes comme Counter-Strike ou Team Fortress. Au fil des années, d'autres genres comme les MMORPG, Battle Royale ou les jeux en coopération ont gagné en popularité.
Nous voulons voir les tendances actuelles et quels types de jeux attirent principalement les joueurs de Steam.

Notre problématique est alors la suivante :

> Quels sont les types de jeu en ligne les plus populaires sur Steam ? (FPS, MMO, etc...)

### Définition de jeu en ligne

Pour commencer notre analyse, il faut tout d'abord définir le terme de **jeu en ligne**.

Une définition de jeu en ligne sera un jeu vidéo dont l'expérience se repose sur l'intéraction entre plusieurs joueurs en temps réel.

Typologies principales :

- `MMO` (Massively Multiplayer Online)
- `Jeux compétitifs` (FPS, MOBA, Battle Royale)
- `Jeux collaboratifs` (ex : Euro Truck Simulator 2)

### ✅ Critères d'identification "jeu en ligne" :

**_Pour qu’un jeu soit considéré comme en ligne :_**

Il doit contenir au moins un des éléments suivants dans ses catégories ou tags :

- `Multiplayer`, `Massively Multiplayer`, `Online Co-op`, etc.

**_Pour mesurer la popularité :_**
On utilise le nombre de joueurs actifs en octobre 2024 (`concurrent_users_yesterday` dans les données).

### 🧩 Types de jeux en ligne

Pour analyser les type de jeux les plus populaires pour les jeux en ligne et regarder sa distribution dans le magasin Steam, on a retenu les tags suivants uniquement :

-   **FPS Multijoueur**
-   **Battle Royale**
-   **RPG en ligne**
-   **Coopération en ligne**
-   **Sandbox**
-   **Survival Multiplayer**
-   **Autres** (correspondant aux autres tags non classés)

```{r get_infos_online_games, include=FALSE}
# Détecter les jeux multijoueurs
jeux_en_ligne <- steamData %>%
  filter(
    (
      str_detect(str_to_lower(categories), "multiplayer|massively multiplayer|online co-op") |
      str_detect(str_to_lower(tags), "multiplayer|mmo|online co-op|pvp|battle royale")
    )
  )

# Classer les jeux en type général selon leur tags
jeux_en_ligne_type <- jeux_en_ligne %>%
  mutate(
    type_de_jeu = case_when(
      str_detect(str_to_lower(tags), "battle royale") ~ "Battle Royale",
      str_detect(str_to_lower(tags), "moba") ~ "MOBA",
      str_detect(str_to_lower(tags), "mmorpg|rpg") ~ "RPG en ligne",
      str_detect(str_to_lower(tags), "survival") ~ "Survival Multijoueur",
      str_detect(str_to_lower(tags), "fps") & str_detect(str_to_lower(tags), "shooter") ~ "FPS Multijoueur",
      TRUE ~ "Autres"
    )
  )

# Grouper par type de jeu et compter les joueurs + le nombre de jeux
popularite_types <- jeux_en_ligne_type %>%
  group_by(type_de_jeu) %>%
  summarise(
    total_joueurs_actifs = sum(concurrent_users_yesterday, na.rm = TRUE),
    nombre_de_jeux = n(),
    .groups = 'drop'
  ) %>%
  arrange(desc(total_joueurs_actifs))

```

### 📊 Analyse des résultats

Voici la répartition des joueurs sur la plateforme Steam sur les jeux en lignes :

```{r barchart,  echo=FALSE, fig.align='center'}
ggplot(popularite_types, aes(x = reorder(type_de_jeu, total_joueurs_actifs), y = total_joueurs_actifs, fill = type_de_jeu)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  theme_minimal() +
    scale_fill_brewer(palette = "Set2") +
  geom_text(aes(label = format(total_joueurs_actifs, big.mark = " ")),
            position = position_stack(vjust = 0.5),
            hjust = 0.5) +
  labs(title = "Total des joueurs actifs par type de jeu",
       x = element_blank(),
       y = "Nombre de joueurs actifs (Octobre 2024)")
```

### 🔎 Observations

- 🥇 **FPS Multijoueur** est de loin le genre dominant avec 1,5 million de joueurs actifs, dont 1,1 million sur Counter-Strike 2 à lui seul.

- **Autres genres** comptent 1,3 million de joueurs avec des jeux variés comme War Thunder, Euro Truck 2, Civilization VI, etc. Cette catégorie montre la diversité des jeux en ligne.

- 🥉 **Battle Royale** regroupe 1 million de joueurs (~16,5 %). Bien qu’en déclin par rapport à 2018-2020, ce genre reste populaire.

- **RPG en ligne** : environ 1,2 million de joueurs. On y trouve :

  - Des MMORPG (Destiny 2, New World, etc.)

  - Des RPG coopératifs (Baldur’s Gate 3, Stardew Valley)

- **Survival Multijoueur** : 800 000 joueurs sur des titres comme Rust, Satisfactory, Factorio.

- **MOBA** : seulement 550 000 joueurs, dont la grande majorité provient de Dota 2.


### 🎯 Les RPG en détails

Nous allons approfondir notre analyse dans le type **RPG** en essayant de séparer et de voir la répartition des RPG en ligne et des MMORPG.

Voici la répartition des joueurs jouant à des MMORPG et des joueurs de RPG classique :

```{r mmo_vs_classicRPG, echo=FALSE, fig.align='center'}
# Filtrer les jeux RPG en ligne et ajouter une colonne is_MMO
mmo_vs_classicRPG <- jeux_en_ligne_type %>%
  filter(type_de_jeu == "RPG en ligne") %>%
  mutate(is_MMO = case_when(
    str_detect(str_to_lower(tags), "mmorpg") ~ TRUE,  # Si le tag "mmorpg" est présent
    TRUE ~ FALSE
  ))

# Calculer le total de jeux RPG en ligne
total_jeux_rpg <- nrow(mmo_vs_classicRPG)

# Regrouper les données pour calculer les proportions globales
proportions_globales <- mmo_vs_classicRPG %>%
  group_by(is_MMO) %>%
  summarise(proportion = n()/total_jeux_rpg)

# Créer le graphique avec les pourcentages sur les barres
ggplot(proportions_globales, aes(x = "", y = proportion, fill = is_MMO)) +
  geom_bar(stat = "identity", width = 0.8) +
  scale_fill_manual(
    values = c("FALSE" = "#4DAF4A", "TRUE" = "#FF7F00"),
    name = "Type de jeu", 
    labels = c("RPG en ligne (non MMO)", "MMORPG")  
  ) +
  geom_text(
    aes(label = scales::percent(proportion, accuracy = 0.1)), 
    position = position_stack(vjust = 0.5)
  ) +
  labs(
    title = "Proportion des joueurs joaunt aux MMORPG aux RPG en ligne (non MMO)",
    x = "", 
    y = "Proportion (%)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.title.x = element_blank()
  )
```

Note : 

- Stardew Valley a le tag RPG et est un jeu qui peut se jouer en multijoueur mais peut-on considérer comme un jeu en ligne ? C'est le cas d'autres jeux principalement singleplayer mais qui peut se jouer en multijoueur.

### ⚠️ Limites de résultats obtenus

-   Les **tags Steam** et les **catégories** créées ne sont **pas assez précises** pour trouver les jeux en ligne car on se retrouve souvent à la frontière d'un jeu avec un système multijoueur et un jeu en ligne.

-   D'autres visualisations au sein des catégories nous permettraient de voir qu'uniquement quelques jeux portent la base de jeu de certains types de jeux comme CS 2 pour les FPS et Dota 2 pour les MOBA.

-   Le fait que la catégorie **"Autres"** possèdent de nombreux jeux en ligne que l'on a pas pu classer montre que le domaine des jeux en ligne est très variée et non cantonnée aux genres que l'on pense habituellement. Globalement, réaliser une classification sur l'ensemble des jeux Steam semble difficile tant certains jeux sont assez particulier pour les catégoriser.

-   Enfin, il faut être conscient que ces données ne concernent que les utilisateurs Steam et non la globalité des joueurs. Par exemple, pour les MMORPG, ceux-ci peuvent être lancés hors Steam. De plus avec l'avènement de l'Epic Game Store, une partie des jeux sont passés sur l'autre plateforme comme Rocket League.


### ------------------------------------------------------------------------


## Analyse des notes des jeux AAA et indies (Paul Lassasseigne)

### Introduction

L'industrie du jeu vidéo traverse une période compliquée depuis plusieurs années. Les plus grosses entreprises du milieu enchaînent des polémiques entre licencements intensifs, management toxique et jeux très moyens aux yeux de la critique dont les prix ne cessent d'augmenter.

**Qu'est ce qu'un jeu AAA ?**

C'est un terme utilisé pour classifier les jeux vidéo dotés de budgets de développement et de promotion élevés. Ce sont donc des jeux censés présenter de grandes qualités.

Cependant, les productions AAA font face à plusieurs critiques récurrentes telles que le manque d'innovation, une uniformisation des contenus, ou encore des pratiques commerciales controversées (microtransactions, loot boxes, DLC abusifs).

À l'opposé, les jeux indépendants sont souvent développés par des équipes réduites ou par des développeurs individuels disposant de moyens financiers et techniques limités. Ce contexte leur permet généralement une plus grande liberté créative, donnant naissance à des jeux originaux, audacieux et parfois innovants.

### Problématique

Face à ce contexte qui oppose budget et innovation, une question se soulève quant à la qualité des jeux auprès du grand public :

> Les jeux indépendants obtiennent-ils de meilleures évaluations que les AAA ?

### Chargement et préparation des données

Afin de réaliser l'analyse, on va utiliser les fichiers [raw_reviews.csv](https://github.com/IF36-visualisation/projet-if36-p25-avatar-le-maitre-du-r/blob/master/data/raw_reviews.csv) et [tags.csv](https://github.com/IF36-visualisation/projet-if36-p25-avatar-le-maitre-du-r/blob/master/data/tags.csv) qui seront suffisants. Les deux fichiers sont reliés par app_id, tags.csv va nous permettre de séparer les jeux par le groupe des jeux indépendants et celui des jeux AAA, et raw_reviews.csv va nous permettre d'obtenir les notes attribuées pour chaque jeu.

### Préparation des jeux

Steam possède un tag spécialement pour les jeux indépendants, qui se nomme "Indie". Ce n'est pas le cas pour les jeux AAA. Cependant, on peut facilement les obtenir en récupérant l'ensemble des jeux, puis en enlevant les jeux indépendants :

```{r}
indie_games <- tags %>%
  mutate(app_id = as.character(app_id)) %>%
  filter(tag == "Indie") %>%
  distinct(app_id) %>%
  mutate(type_game = "Indépendant")

aaa_games <- tags %>%
  mutate(app_id = as.character(app_id)) %>%
  anti_join(indie_games, by = "app_id") %>%
  distinct(app_id) %>%
  mutate(type_game = "AAA")

nrow(indie_games)
nrow(aaa_games)

types_games <- bind_rows(indie_games, aaa_games)
```

Par la suite, on peut tout mettre dans un nouveau dataset nommé types_games qui recense l'ensemble des jeux avec leur catégorie propre.

### Préparation des évaluations

Pour les évaluations, on va créer un nouveau dataset avec seulement les informations dont nous avons besoin, c'est à dire app_id et review_score_description. On va ensuite filtrer review_score_description afin d'obtenir seulement les jeux qui ont une évaluation. La colonne peut avoir d'autres valeurs, comme "None", "1 user reviews" etc... car Steam attribue une évaluation à un jeu seulement à partir d'un certain nombre d'évaluations de la part de la communauté.

```{r}
evaluations <- reviews %>%
  filter(review_score_description %in% c(
    "Very Negative", "Mostly Negative", "Mixed",
    "Mostly Positive", "Very Positive", "Overwhelmingly Positive"
  )) %>%
  select(app_id, review_score_description) %>%
  inner_join(types_games, by = "app_id")
```

### Visualisation

Enfin, pour la visualisation de nos données, on s'est orienté sur un diagramme à barres. L'objectif est de comparer directement les types de jeu selon le niveau d'évaluation.

```{r}
evaluations %>%
  mutate(review_score_description = factor(review_score_description, levels = c("Very Negative", "Mostly Negative", "Mixed", "Mostly Positive", "Very Positive", "Overwhelmingly Positive"))) %>%
  count(review_score_description, type_game) %>%
  ggplot(aes(x = review_score_description, y = n, fill = type_game)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = c("Indépendant" = "red", "AAA" = "blue")) +
  labs(
    title = "Répartition du nombre de jeux par évaluation et par type",
    x = "Niveau d'évaluation",
    y = "Nombre de jeux",
    fill = "Type de jeu"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Le problème est que ce n'est pas égal de faire la comparaison actuellement. Comme on peut le voir plus au dessus grâce à la fonction nrow, aaa_games possède 54 252 jeux, tandis que indie_games en possède 63 253. On va donc faire une moyenne globale pour être au même niveau.

La fonction geom_bar nous permet de définir l'option "position = dodge" afin d'avoir les barres côte à côte pour une meilleure lisibilité.

```{r}
evaluations %>%
  mutate(review_score_description = factor(review_score_description, levels = c("Very Negative", "Mostly Negative", "Mixed", "Mostly Positive", "Very Positive", "Overwhelmingly Positive"))) %>%
  count(review_score_description, type_game) %>%
  group_by(type_game) %>%
  mutate(percentage = n / sum(n) * 100) %>%
  ggplot(aes(x = review_score_description, y = percentage, fill = type_game)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = sprintf("%.1f%%", percentage)), 
          position = position_dodge(width = 1), 
          vjust = -0.25, size = 3) +
  scale_fill_manual(values = c("Indépendant" = "red", "AAA" = "blue")) +
  labs(
    title = "Répartition proportionnelle des évaluations par type de jeu",
    x = "Niveau d'évaluation",
    y = "Pourcentage de jeux",
    fill = "Type de jeu"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Observations

L'analyse du graphique montre que, proportionnellement, les jeux AAA obtiennent légèrement plus d'évaluations "Very Positive" que les jeux indépendants. Toutefois, les différences restent relativement faibles et la majorité des jeux indépendants se situent également dans des évaluations globalement positives. Les jeux indépendants affichent une proportion un peu plus élevée d'évaluations "Mixed", ce qui pourrait refléter une plus grande diversité de qualité au sein de cette catégorie. Cela amène à nuancer l'hypothèse initiale : si les jeux indépendants reçoivent beaucoup de bonnes évaluations, les jeux AAA conservent tout de même une légère avance en termes de perception positive moyenne sur Steam.

Cette hypothèse vient du fait que aujourd'hui, les joueurs sont focalisés sur un léger pourcentage de jeux par rapport à l'entièreté du monde du jeu vidéo. Tous les jours de nouveaux jeux sortent, tous les jours il peut y en avoir d'excellents, mais ils ne feront pas le même bruit que les jeux colossaux développés par les grandes entreprises, comme Microsoft, Ubisoft, Activision Blizzard, Rockstar etc...


### 🔎 Focus sur différents studios de jeux

Dans cette section, nous nous intéressons à trois studios aux profils très différents afin de comparer les jeux qu’ils produisent, notamment en termes de notes et réception critique :

- **Ubisoft** : un studio mythique et reconnu qui produit des jeux AAA
- **Supergiant Games** : un studio indépendant qui produit des jeux indépendants
- **FromSoftware Inc.** : un studio produisant des jeux AAA mais dans un registre différent qu'Ubisoft

L'objectif de cette partie est de regarder les notes des différents jeux des studios avec leurs approches différentes en terme de production de jeux vidéos et d'explorer davantage la question de la notation et de la potentiel influence du tag `indie`.
Nous allons prendre les 5 jeux de chaque studio ayant obtenu le plus de notes sur Steam.

### Notes obtenus

```{r Ubisoft vs Supergiant, results='markup'}
# Obtenir les jeux des studios
ubisoft_games <- steamData %>%
  filter(str_detect(tolower(developer), "ubisoft")) %>%
  filter(type=='game') %>%
  select(proportion_avis_positif, metacritic_score, name, release_date, owners_range, total)
  

supergiant_games <-steamData %>%
    filter(str_detect(tolower(developer), "supergiant games")) %>%
    filter(type=='game') %>%
    select(proportion_avis_positif, metacritic_score, name, release_date, owners_range, total)

fromsoftware_games = steamData %>%
    filter(str_detect(tolower(developer), "fromsoftware")) %>%
    filter(type=='game') %>%
    select(proportion_avis_positif, metacritic_score, name, release_date, owners_range, total)

# On prends les 5 jeux qui ont le plus d'avis (pas forcément les jeux qui ont le plus de propriétaires)
top5_ubisoft = ubisoft_games %>%
  arrange(desc(total)) %>%
  slice_head(n=5)

top5_supergiant = supergiant_games %>%
  arrange(desc(total)) %>%
  slice_head(n=5)

top5_fromsoftware = fromsoftware_games %>%
  arrange(desc(total)) %>%
  slice_head(n=5)

# Table Ubisoft
top5_ubisoft <- top5_ubisoft %>%
  select(name, release_date, metacritic_score, proportion_avis_positif, total) %>%
  mutate (proportion_avis_positif = proportion_avis_positif * 100) %>%
  rename(
    Jeu = name,
    `Date de sortie` = release_date,
    `Note Metacritic` = metacritic_score,
    `Proportion d'avis positif Steam` = proportion_avis_positif,
    `Nombre d'avis total` = total
  )

kable(top5_ubisoft,
      caption = "Notes des jeux Ubisoft", digits = 2)

# Table Supergiant
top5_supergiant <- top5_supergiant %>%
  select(name, release_date, metacritic_score, proportion_avis_positif, total) %>%
  mutate (proportion_avis_positif = proportion_avis_positif * 100) %>%
  rename(
    Jeu = name,
    `Date de sortie` = release_date,
    `Note Metacritic` = metacritic_score,
    `Proportion d'avis positif Steam` = proportion_avis_positif,
    `Nombre d'avis total` = total
  )

kable(top5_supergiant,
      caption = "Notes des jeux Supergiant Games", digits = 2)

# Table Fromsoftware
top5_fromsoftware <- top5_fromsoftware %>%
  select(name, release_date, metacritic_score, proportion_avis_positif, total) %>%
  mutate (proportion_avis_positif = proportion_avis_positif * 100) %>%
  rename(
    Jeu = name,
    `Date de sortie` = release_date,
    `Note Metacritic` = metacritic_score,
    `Proportion d'avis positif Steam` = proportion_avis_positif,
    `Nombre d'avis total` = total
  )

kable(top5_fromsoftware,
      caption = "Notes des jeux FromSoftware Inc.", digits = 2)
```

### 🔎 Observations

- On note que les notes les plus élevées ont été obtenus par les jeux de **Supergiant Games**, le studio de jeux indépendant qui ne possède pas le budget des deux autres studios.

- Cependant, cela reste à nuancer : le nombre total de note est nettement moins élevé pour les jeux de Supergiant Games comparé aux jeux des deux studios.

- On ne peut pas conclure facilement que les jeux d'un studio indie reconnu obtiennent de meilleures notes que les studios AAA car les jeux de **FromSoftware Inc.** obtiennent des bonnes notes (environ 90% d'approbation sur les jeux les plus notés du studio).

### ------------------------------------------------------------------------


## Tendance des jeux sortis récemments (Jules PERRIN)
# Contexte général
Steam est une plateforme qui propose l'un des plus gros catalogue de jeux vidéo du marché. Chaque jeu proposé a plusieurs caractéristiques (nom, prix, éditeur , etc). Parmi ces caractéristiques, l'une d'entre elle nous intéresse particulièrement dans ce rapport. En effet les tags permettent aux joueurs de se faire une idée rapide des jeux proposés ou encore de rechercher de nouveaux jeux selon leur préférences.

Le jeu de données que nous allons utiliser ne comporte pas de données permettant de dresser une temporalité. Ce rapport portera donc sur les données du catalogue Steam en octobre 2024.

Les catégories ne doivent pas être confondues avec les tags. Ici les catégories représentent comment l'on joue au jeu (multiplayer, online pvp, remote play on phone etc). Alors que les tags représentent à quoi l'on joue (survival, tactical, FPS, old school, etc). 

# Problématique

Ce rapport traitera une question pour le moment: 

 - Quelle est la tendance des jeux sortis récemment ?
 
Cela nous permettra d'avoir une idée globale de la dispersion des joueurs dans les catégories majeurs sur steam pour les nouveaux jeux. Pourrait être utile à un studio pour orienter son futur jeux vidéo par example. 
 
# Analyse
## Import des données

Premièrement il faut importer les données nécessaires à cette analyse.
Ainsi que charger les librairies requises pour travailler et visualiser les données
Les données des fichiers tags, steamspy et games sont nécéssaires

```{r importe, message=FALSE, warning=FALSE}
library(tidyr)
library(scales)
library(lubridate)
library(ggplot2)
library(tidyverse)

steamspy <- read_csv("data/steamspy.csv")
tags <- read_csv("data/tags.csv")
games <- read_delim("data/clean_games.csv", delim=";", show_col_types = FALSE)
```

### Précision et définition

Ici on cherche à représenter la tendance actuelle. On utilisera donc la population steam présente le jour de la construction du dataset (bien que pas objectivement représentatif cf. interprétation). On cherche également à se concentrer sur les jeux récents. On utilisera donc tous les jeux sortis en 2024

```{r}
games_2024 <- games %>%
  mutate(release_date = ymd(release_date)) %>%
  filter(year(release_date) == 2024) %>%
  select(app_id)

tag_players <- tags %>% 
  semi_join(games_2024, by = "app_id") %>%
  left_join(steamspy %>% 
              select(app_id, concurrent_users_yesterday),
            by = "app_id") %>%
  group_by(tag) %>% 
  summarise(total_ccu = sum(concurrent_users_yesterday, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_ccu)) %>% 
  slice_head(n = 10)

tag_players %>%
  mutate(total_ccu = formatC(total_ccu, format = "d", big.mark = " ")) %>% 
  knitr::kable(
    col.names = c("Tags", "Joueur connectés"), 
    caption = "Top 10 des tags pour les jeux de 2024",
    align = c("l", "r")
  )
```

Voila donc un aperçu des tags les plus populaires selon le contexte établi

### Visualisation

```{r}
ggplot(tag_players, 
       aes(x = reorder(tag, total_ccu), 
           y = total_ccu)) +
         geom_col(fill = "steelblue") +
         coord_flip() + 
         scale_y_continuous(labels = comma) + 
         geom_text(aes(label = comma(total_ccu)),
                   hjust = -0.1, size = 3) + 
         labs(title = "Meilleur tag de l'année", 
              x = NULL,
              y = "joueur connecté a la création du dataset") + 
         theme_minimal()
```

### Interprétation

On peut observer des tags assez génériques néanmoins on peut s'interroger sur la présence d'early access. Est ce que cette position dans les tags résulte de la curiosité des joueurs pour les jeux "non sortis" en général. Ou bien est-ce qu'un triple A était très attendu et est sorti en early acces en 2024.

On peut également observer que les jeux multi et single player se valent mais cette interprétation est à nuancer car les jeux peuvent avoir les 2 tags de par la présence d'une campagne ou d'un mode histoire.

Les jeux en Coop sont significativement au delà des jeux coop online. Cela pourrait se traduire par l'envie des joueurs de jouer uniquement avec leurs amis ou au moins de ne pas jouer avec des gens aléatoire qui pourraientt avoir un écart de niveau important ou juste vouloir "troller". au demeurant, les jeux coop n'ont pas forcement de mode en ligne

### Limites et attentions

Il faut absolument garder en tête que le dataset ne se base pas sur tout l'historique de steam mais bien sur une journée ce qui peut donc ne pas être représentatif à la perfection.

Les résultat présents sont limités par le fait que beaucoup de jeux peuvent avoir plusieurs tags et donc compter plusieurs fois et biaiser les résultat. Ici impossible de faire la distcntion car il n'y a pas de hiérarchisation des tags. Néamoins une possibilité pourrait être de donner un poids aà certains tags trop générique pour observer des résultat plus axé sur le theme du jeux en lui même (military plutot que multiplayer)

Nous sommes également limité par l'explicité des tags, par exemple, Coop online est-il réservé au jeux qui proposent un matchmaking ou aux jeux permettant d'invité ses amis ou les deux. Ces petites imprécision affecte également la pertinence de l'analyse.





```{r}
#caté les plus populaires sur steam
# Nécessite les packages suivants :
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)


library(scales)
# Jointure des catégories et données de popularité
cat_pop <- left_join(steamspy, categories, by = "app_id")

# Calcul de la borne minimale d'owners pour chaque catégorie
cat_pop_long <- cat_pop %>%
  filter(!is.na(categories) & !is.na(owners_range)) %>%
  separate_rows(categories, sep = ",") %>%
  mutate(
    owner_min = as.numeric(str_replace_all(str_extract(owners_range, "^[0-9,]+"), ",", ""))
  ) %>%
  group_by(categories) %>%
  summarise(
    total_owner_min = sum(owner_min, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(total_owner_min))

# Sélection des 50 catégories les plus populaires
top50_cat <- cat_pop_long %>% slice_max(total_owner_min, n = 20)

# Affichage du graphique avec catégories en abscisse
ggplot(top50_cat, aes(x = reorder(categories, total_owner_min), y = total_owner_min)) +
  geom_col(width = 0.3, fill = "blue") +
  labs(
    title = "Top 50 des catégories Steam par nombre minimal de possesseurs",
    x = "Catégorie",
    y = "Somme des bornes minimales de possesseurs"
  ) +
  scale_y_continuous(labels = comma) +  # <--- C'est cette ligne qui enlève les exposants
  theme_minimal(base_size = 10) +
  theme(
    axis.text.x = element_text(angle = 75, hjust = 1, size = 7),
    plot.title = element_text(size = 13, face = "bold"),
    axis.title.x = element_text(size = 10),
    axis.title.y = element_text(size = 10)
  )


```







```{r}

library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)

# Préparation des données de base
games_tags <- left_join(tags, clean_games %>% select(app_id, release_date), by = "app_id") %>%
  filter(!is.na(tag), !is.na(release_date)) %>%
  mutate(year = year(ymd(release_date)))

## 1. Global : tous les jeux (top 10 tags)
genre_year_all <- games_tags %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_all <- genre_year_all %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_all_top <- genre_year_all %>% filter(tag %in% top_tags_all)

# Graphique global
ggplot(genre_year_all_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  labs(
    title = "Évolution du nombre de jeux sortis par tag ",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)

## 2. Jeux sortis avant ou en 2015 (top 10 tags)
games_tags_pre2015 <- games_tags %>% filter(year <= 2013) %>% filter(year > 2005)
genre_year_pre2015 <- games_tags_pre2015 %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_pre2015 <- genre_year_pre2015 %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_pre2015_top <- genre_year_pre2015 %>% filter(tag %in% top_tags_pre2015)

# Graphique avant 2013 et après 2005
ggplot(genre_year_pre2015_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  labs(
    title = "Évolution des tags pour les jeux sortis avant ou en 2013",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)

## 3. Jeux sortis après 2013 
games_tags_post2015 <- games_tags %>% filter(year > 2013)
genre_year_post2015 <- games_tags_post2015 %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_post2015 <- genre_year_post2015 %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_post2015_top <- genre_year_post2015 %>% filter(tag %in% top_tags_post2015)

# Graphique après 2013
ggplot(genre_year_post2015_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  labs(
    title = "Évolution des tags pour les jeux sortis après 2013",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)


```


```{r}
# 1. Préparation des données
games_tags <- left_join(tags, clean_games %>% select(app_id, release_date), by = "app_id") %>%
  filter(!is.na(tag), !is.na(release_date)) %>%
  mutate(year = year(ymd(release_date)))

games_with_owners <- games_tags %>%
  left_join(
    steamspy %>%
      mutate(owner_min = as.numeric(str_replace_all(str_extract(owners_range, "^[0-9,]+"), ",", ""))),
    by = "app_id"
  ) %>%
  left_join(clean_games %>% select(app_id, name), by = "app_id")

# 2. Fonction utilitaire pour top jeu par année
get_top_game_by_year <- function(df) {
  df %>%
    group_by(year, app_id, name) %>%
    summarise(owner_min = max(owner_min, na.rm = TRUE), .groups = "drop") %>%
    filter(!is.na(year), !is.na(owner_min)) %>%
    group_by(year) %>%
    slice_max(order_by = owner_min, n = 1, with_ties = FALSE) %>%
    ungroup()
}

# 3. Fonction utilitaire pour placer les labels en haut
get_label_position <- function(curve_data, top_game_data) {
  max_y_per_year <- curve_data %>%
    group_by(year) %>%
    summarise(y_max = max(n), .groups = "drop")
  left_join(top_game_data, max_y_per_year, by = "year")
}

### --- Période avant ou en 2013 ---
games_pre2013 <- games_with_owners %>% filter(year <= 2013) %>% filter(year > 2005)
genre_year_pre2013 <- games_pre2013 %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_pre2013 <- genre_year_pre2013 %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_pre2013_top <- genre_year_pre2013 %>% filter(tag %in% top_tags_pre2013)
top_game_pre2013 <- get_top_game_by_year(games_pre2013)
top_game_pre2013_label <- get_label_position(genre_year_pre2013_top, top_game_pre2013)

### --- Période après 2013 ---
games_post2013 <- games_with_owners %>% filter(year > 2013)
genre_year_post2013 <- games_post2013 %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_post2013 <- genre_year_post2013 %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_post2013_top <- genre_year_post2013 %>% filter(tag %in% top_tags_post2013)
top_game_post2013 <- get_top_game_by_year(games_post2013)
top_game_post2013_label <- get_label_position(genre_year_post2013_top, top_game_post2013)

### --- Période globale (toutes années) ---
genre_year_all <- games_with_owners %>%
  group_by(year, tag) %>%
  summarise(n = n(), .groups = "drop")
top_tags_all <- genre_year_all %>%
  group_by(tag) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice_head(n = 10) %>%
  pull(tag)
genre_year_all_top <- genre_year_all %>% filter(tag %in% top_tags_all)
top_game_all <- get_top_game_by_year(games_with_owners)
top_game_all_label <- get_label_position(genre_year_all_top, top_game_all)

# --- Graphique 1 : avant ou en 2013 ---
ggplot(genre_year_pre2013_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  geom_vline(
    data = top_game_pre2013_label, 
    aes(xintercept = year), 
    linetype = "dotted", color = "black", linewidth = 0.6
  ) +
  geom_text(
    data = top_game_pre2013_label,
    aes(x = year, y = y_max, label = stringr::str_trunc(name, 15, "right")),
    color = "black",
    angle = 90, vjust = -0.5, hjust = 0, size = 2.7
  ) +
  labs(
    title = "Évolution des tags - Jeux sortis avant ou en 2013\n+ jeu le plus possédé chaque année",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)

# --- Graphique 2 : après 2013 ---
ggplot(genre_year_post2013_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  geom_vline(
    data = top_game_post2013_label, 
    aes(xintercept = year), 
    linetype = "dotted", color = "black", linewidth = 0.6
  ) +
  geom_text(
    data = top_game_post2013_label,
    aes(x = year, y = y_max, label = stringr::str_trunc(name, 15, "right")),
    color = "black",
    angle = 90, vjust = -0.5, hjust = 0, size = 2.7
  ) +
  labs(
    title = "Évolution des tags - Jeux sortis après 2013\n+ jeu le plus possédé chaque année",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)

# --- Graphique 3 : global ---
ggplot(genre_year_all_top, aes(x = year, y = n, color = tag)) +
  geom_line(linewidth = 1.1) +
  geom_point(size = 1.6) +
  geom_vline(
    data = top_game_all_label, 
    aes(xintercept = year), 
    linetype = "dotted", color = "black", linewidth = 0.6
  ) +
  geom_text(
    data = top_game_all_label,
    aes(x = year, y = y_max, label = stringr::str_trunc(name, 15, "right")),
    color = "black",
    angle = 90, vjust = -0.5, hjust = 0, size = 2.7
  ) +
  labs(
    title = "Évolution des tags - Toutes années\n+ jeu le plus possédé chaque année ",
    x = "Année de sortie",
    y = "Nombre de jeux sortis",
    color = "Tag"
  ) +
  theme_minimal(base_size = 10)

```




